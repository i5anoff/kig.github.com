<html>
  <head>
    <style>
      body {
        overflow: hidden;
        font-family: Ubuntu, sans-serif;
      }
      #palette {
        width: 0px;
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 10;
      }
      #replay {
        margin-bottom: 20px;
      }
      #fileIO {
        text-align: right;
        z-index: 10;
        top: 10px;
        right: 10px;
        position: absolute;
      }
      #foregroundColor {
/*        position: absolute;
        display: block;*/
        display: inline-block;
        width: 40px;
        height: 30px;
        margin-bottom: 20px;
        border: 1px solid gray;
        z-index: 1;
        cursor: pointer;
      }
      #backgroundColor {
        width: 40px;
        height: 20px;
        display: none;
        margin-top: 3px;
        margin-left: 3px;
        margin-bottom: 20px;
        border: 1px solid gray;
        z-index: 0;
      }
      #colorPicker {
        margin-bottom: 20px;
      }
      .paletteColor {
        width: 20px;
        height: 20px;
        border: 1px solid gray;
        display: inline-block;
        margin-bottom: 2px;
        margin-right: 2px;
        cursor: pointer;
      }
      .paletteColor + .brushWidth {
        margin-top: 10px;
      }
      .brushWidth {
        width: 20px;
        height: 15px;
        display: block;
        margin-bottom: 10px;
        cursor: pointer;
      }
      #helpToggle {
        font-size: 17px;
        cursor: pointer;
        position: absolute;
        right: 0px;
        top: 30px;
        text-shadow: 0px 0px 5px white;
        width: 22px;
        text-align: center;
      }
      #help {
        display: none;
        position: absolute;
        right: 34px;
        top: 34px;
        padding: 10px;
        padding-top: 4px;
        padding-right: 14px;
        border-radius: 10px;
        background-color: rgba(255,255,255,0.8);
      }
      #help p {
        font-size: 12px;
        margin-bottom: 4px;
        margin-top: 0px;
      }
    </style>
    <script src="magi.js"></script>
    <script>

      DrawHistorySerializer = Klass({
        magic: 'SRBL',
        majorVersion: 0,
        minorVersion: 0,

        initialize : function() {},

        getVersionTag : function() {
          return [this.magic, this.majorVersion, this.minorVersion, ''].join(",")
        },

        serialize : function(history) {
          return [this.getVersionTag(), this.serializeBody(history)].join("");
        },

        deserialize : function(string) {
          var t = this.getVersionTag();
          if (string.substring(0, t.length) != t)
            throw (new Error("Unknown version tag"))
          return this.deserializeBody(string.substring(t.length));
        },

        serializeBody : function(history) {
          return JSON.stringify(history);
        },

        deserializeBody : function(history) {
          return JSON.parse(history);
        }
      });

      CompressedDrawHistorySerializer = Klass(DrawHistorySerializer, {
        commands : [
          'drawPoint',
          'drawLine',
          'clear',
          'setColor',
          'setBackground',
          'setLineCap',
          'setLineWidth',
          'setOpacity'
        ],
        collapsible : {
          'clear' : true,
          'setColor' : true,
          'setBackground' : true,
          'setLineCap' : true,
          'setLineWidth' : true,
          'setOpacity' : true
        },
        majorVersion: 1,
        minorVersion: 0,

        initialize : function() {
          this.commandCodes = {};
          for (var i=0; i<this.commands.length; i++) {
            this.commandCodes[this.commands[i]] = i;
          }
        },

        serializeBody : function(history) {
          var output = [];
          for (var i=0; i<history.length; i++) {
            var e = history[i];
            if (this.collapsible[e.methodName] && history[i+1]
                && history[i+1].methodName == e.methodName) {
              // only the last element matters in a string of collapsible actions
              // (a = 1; a = 2; a = 3; a = 4) <=> (a = 4)
              continue;
            }
            var cmd = this.commandCodes[e.methodName];
            if (e.methodName == 'drawLine') {
              // delta-encode a string of drawLine actions
              var coords = [e.args[0], e.args[1]];
              e = history[i+1];
              while (e && e.methodName == 'drawLine') {
                if (this.canDeltaEncode(coords, e.args))
                  coords.push(e.args[1]);
                else
                  break;
                i++;
                e = history[i+1];
              }
              var deltaString = this.deltaEncode(coords);
              output.push(cmd + this.encodeInt16(deltaString.length) + deltaString);
              continue;
            } else {
              var args = this.encodeArgs(e.args);
              output.push(cmd + args);
            }
          }
          return output.join("");
        },

        deserializeBody : function(string) {
          var output = [];
          var obj = {};
          for (var i=0; i<string.length;) {
            i += this.readCommand(string, obj);
            if (obj.methodName == 'drawLine') {
              var coords = this.decodeDeltas(obj.args);
              for (var j=0; j<coords.length; j++)
                output.push({methodName: 'drawLine', args: coords[j]});
            } else {
              var o = {methodName: obj.methodName, args: obj.args};
              if (this.breakpointMethod[obj.methodName])
                o.breakpoint = true;
              output.push(o);
            }
          }
          return output;
        },

        canDeltaEncode : function(coords, args) {
          var l = coords.last();
          return (
            coords.length < 30000 &&
            (l.x == args[0].x && l.y == args[0].y) &&
            (Math.abs(l.x-args[1].x) < 127 && Math.abs(l.y-args[1].y) < 127)
          );
        },

        deltaEncode : function(coords) {
          var base = coords[0];
          var deltas = [this.encodeInt16(base.x),this.encodeInt16(base.y)];
          for (var i=1; i<coords.length-1; i++) {
            var prev = coords[i-1];
            var cur = coords[i];
            // these could be entropy-encoded
            deltas.push(this.encodeInt8(cur.x-prev.x), this.encodeInt8(cur.y-prev.y));
          }
          return deltas.join("");
        }
      });


      Undoable = Klass({
        historySnapshotEventCount : 3500,
        playbackRate : 5, // events per millisecond
        recordHistory : true,
        historyIndex : -1,

        initialize : function() {
          this.clearHistory();
        },

        /**
          Applies history state.
          You need to overwrite this.
        */
        applyHistoryState : function(state) {
          throw(new Error("Undoable.applyHistorystate: Not implemented"));
        },

        /**
          Creates a new snapshot of current object state and
          returns it.
          You need to overwrite this.
        */
        createSnapshot : function() {
          throw(new Error("Undoable.createSnapshot: Not implemented"));
          // return snapshot;
        },

        /**
          Applies an object state snapshot.
          You need to overwrite this.
        */
        applySnapshot : function(snapshot) {
          throw(new Error("Undoable.applySnapshot: Not implemented"));
        },


        addSnapshot : function() {
          this.snapshots.push({
            historyIndex: this.historyIndex,
            value: this.createSnapshot()
          });
        },

        getSnapshot : function(index) {
          for (var i=1; i<this.snapshots.length; i++) {
            if (this.snapshots[i].historyIndex > index) {
              return this.snapshots[i-1];
            }
          }
          return this.snapshots.last();
        },

        addHistoryState : function(obj) {
          if (this.recordHistory) {
            this.historyIndex++;
            this.history[this.historyIndex] = obj;
            if (this.history.length > this.historyIndex+1) {
              this.history.splice(this.historyIndex+1);
              var sidx = Math.floor(this.historyIndex / this.historySnapshotEventCount);
              if (this.snapshots.length > sidx+1) {
                this.snapshots.splice(sidx+1);
              }
            }
            if (this.historyIndex % this.historySnapshotEventCount == 0) {
              this.addSnapshot();
            }
          }
        },

        gotoHistoryState : function(index) {
          index = Math.clamp(index, 0, this.history.length-1);
          if (index == this.historyIndex) return;
          var snapshot = this.getSnapshot(index);
          this.recordHistory = false;
          this.applySnapshot(snapshot.value);
          for (var i=snapshot.historyIndex+1; i<=index; i++) {
            this.applyHistoryState(this.history[i]);
          }
          this.recordHistory = true;
          this.historyIndex = index;
        },

        undo : function() {
          var lastPoint = this.historyIndex;
          for (var i=lastPoint; i>=0; i--) {
            if (this.history[i].breakpoint) {
              lastPoint = i;
              break;
            }
          }
          this.gotoHistoryState(lastPoint-1);
        },

        redo : function() {
          var nextPoint = this.history.length;
          for (var i=this.historyIndex+2; i<this.history.length; i++) {
            if (this.history[i].breakpoint) {
              nextPoint = i;
              break;
            }
          }
          this.gotoHistoryState(nextPoint-1);
        },

        clearHistory : function() {
          this.history = [];
          this.snapshots = [];
          this.historyIndex = -1;
        },

        playbackHistory : function() {
          var h = this.history;
          this.recordHistory = false;
          var i=0;
          var self = this;
          var ival = setInterval(function() {
            if (i > self.historyIndex) {
              clearInterval(ival);
              self.recordHistory = true;
            } else {
              var t = new Date();
              var j = i;
              while (new Date() - t < 30 && i <= self.historyIndex && (i-j) < self.playbackRate*10) {
                var cmd = h[i];
                self.applyHistoryState(cmd);
                i++;
              }
              if (window.console) {
                console.log(
                  'Played back '+(i-j)+' events at a rate of ' +
                  Math.floor(1000*(i-j) / (new Date()-t)) +
                  ' events per second'
                );
              }
            }
          }, 10);
        }
      });


      RoundBrushCursor = Klass({
        x : 0,
        y : 0,
        sz : 64,
        minSz : 64,

        initialize : function() {
          this.cursorCanvas = E.canvas(this.sz, this.sz);
          this.cursorCanvas.style.position = 'absolute';
          this.cursorCanvas.style.zIndex = '5';
          this.cursorCanvas.style.pointerEvents = 'none';
          document.body.appendChild(this.cursorCanvas);
        },

        update : function(diameter) {
          var ctx = this.cursorCanvas.getContext('2d');
          var w = this.sz;
          if (w > this.minSz && (w > diameter*4 || (w > 512 && w > diameter*2))) {
            while (w > this.minSz && (w > diameter*4 || (w > 512 && w > diameter*2)))
              w /= 2;
            this.cursorCanvas.width = this.cursorCanvas.height = w;
            console.log('scale down to '+w);
          } else if (w < diameter+2) {
            while (w < diameter+2)
              w *= 2
            this.cursorCanvas.width = this.cursorCanvas.height = w;
            console.log('scale up to '+w);
          }
          this.sz = w;
          ctx.clearRect(0,0,w,w);
          ctx.beginPath();
          ctx.lineWidth = 0.75;
          ctx.arc(w/2, w/2, diameter/2+0.25, 0, Math.PI*2);
          ctx.strokeStyle = '#ffffff';
          ctx.stroke();
          ctx.beginPath();
          ctx.lineWidth = 0.5;
          ctx.arc(w/2, w/2, diameter/2, 0, Math.PI*2);
          ctx.strokeStyle = '#000000';
          ctx.stroke();
          if (diameter < 3) {
            ctx.beginPath();
            ctx.moveTo(w/2+2, w/2);
            ctx.lineTo(w/2+4, w/2);
            ctx.moveTo(w/2-2, w/2);
            ctx.lineTo(w/2-4, w/2);
            ctx.moveTo(w/2, w/2-2);
            ctx.lineTo(w/2, w/2-4);
            ctx.moveTo(w/2, w/2+2);
            ctx.lineTo(w/2, w/2+4);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 0.5;
            ctx.stroke();
          }
          this.moveTo(this.x, this.y);
        },

        moveTo : function(x, y) {
          this.x = x;
          this.y = y;
          this.cursorCanvas.style.left = this.x - this.sz/2 + 'px';
          this.cursorCanvas.style.top = this.y - this.sz/2 + 'px';
        }
      });


      ColorUtils = Klass(Magi.Colors, {

        colorToStyle : function(c) {
          return (
            'rgba('+Math.floor(c[0]*255)+
                ','+Math.floor(c[1]*255)+
                ','+Math.floor(c[2]*255)+
                ','+c[3]+')'
          );
        },

        styleToColor : function(c) {
          var r=0,g=0,b=0,a=0;
          if (/^#/.test(c)) {
            r = parseInt(c.substring(1,3), 16) / 255;
            g = parseInt(c.substring(3,5), 16) / 255;
            b = parseInt(c.substring(5,7), 16) / 255;
            a = 1;
            if (c.length == 9)
              a = parseInt(c.substring(7,9), 16) / 255;
          } else if (/^rgba/.test(c)) {
            rgba = c.substring(5,c.length-1).split(",").map(parseFloat);
            r = rgba[0] / 255;
            g = rgba[1] / 255;
            b = rgba[2] / 255;
            a = rgba[3];
          } else if (/^rgb/.test(c)) {
            rgb = c.substring(4,c.length-1).split(",").map(parseFloat);
            r = rgb[0] / 255;
            g = rgb[1] / 255;
            b = rgb[2] / 255;
            a = 1.0;
          }
          return [r,g,b,a];
        },

        tween : function(a, b, f) {
          var r = [];
          for (var i=0; i<a.length; i++) {
            r[i] = a[i]*(1-f) + b[i]*f;
          }
          return r;
        },

        tweenColor : function(a, b, f) {
          var c = this.tween(a,b,f);
          return this.colorToStyle(c);
        },

        averageColor : function(imageData) {
          var d = imageData.data;
          var r=0, g=0, b=0, a=0;
          for (var i=-1, dl=d.length-1; i<dl;) {
            r += d[++i];
            g += d[++i];
            b += d[++i];
            a += d[++i];
          }
          var l = d.length / 4;
          return [ r/l, g/l, b/l, a/l ];
        },

        colorAt : function(ctx, x, y, radius) {
          radius = radius || 1;
          var id = ctx.getImageData(x-(radius-1), y-(radius-1), 2*radius-1, 2*radius-1);
          var c = this.averageColor(id);
          c[0] /= 255;
          c[1] /= 255;
          c[2] /= 255;
          c[3] /= 255;
          return c;
        }
      });


      Math.clamp = function(v, min, max) {
        return Math.min(max, Math.max(min, v));
      };

      ColorPicker = Klass(ColorUtils, {
        hue : 0,

        initialize: function(container, width, height, callback) {
          var self = this;
          this.callback = callback;
          this.canvas = E.canvas(width, height);
          this.ctx = this.canvas.getContext('2d');
          container.appendChild(this.canvas);
          this.cursor = new RoundBrushCursor();
          this.cursor.cursorCanvas.style.zIndex = 11;
          this.cursor.update(8);
          this.hueCanvas = E.canvas(width, 15);
          this.hueCtx = this.hueCanvas.getContext('2d');
          for (var i=0; i<width; i++) {
            var rgb = this.hsv2rgb(i/width*360, 1,1);
            rgb[3] = 1;
            this.hueCtx.fillStyle = this.colorToStyle(rgb);
            this.hueCtx.fillRect(i,0,1,15);
          }
          this.hueCtx.fillStyle = 'black';
          this.hueCtx.fillRect(0,0,width,3);
          var hc = this.hueCanvas;
          var cc = this.canvas;
          var rect = this.canvas.getBoundingClientRect();
          this.cursor.moveTo(rect.left, rect.top);
          hc.addEventListener('mousedown', function(ev) {
            this.down = true;
            var xy = Mouse.getRelativeCoords(hc, ev);
            var h = Math.clamp(xy.x/width, 0, (width-1)/width);
            self.setHue(h*360);
            var c = self.colorAt(self.ctx, self.cursor.x-rect.left, self.cursor.y-rect.top);
            self.callback(c);
            ev.preventDefault();
          }, false);
          cc.addEventListener('mousedown', function(ev) {
            this.down = true;
            var xy = Mouse.getRelativeCoords(cc, ev);
            var x = Math.clamp(xy.x, 0, width-1);
            var y = Math.clamp(xy.y, 0, height-1);
            var c = self.colorAt(self.ctx, x, y);
            self.cursor.moveTo(rect.left+x, rect.top+y);
            self.callback(c);
            ev.preventDefault();
          }, false);
          window.addEventListener('mousemove', function(ev) {
            if (hc.down) {
              var xy = Mouse.getRelativeCoords(hc, ev);
              var h = Math.clamp(xy.x/width, 0, (width-1)/width);
              self.setHue(h*360);
              var c = self.colorAt(self.ctx, self.cursor.x-rect.left, self.cursor.y-rect.top);
              self.callback(c);
              ev.preventDefault();
            } else if (cc.down) {
              var xy = Mouse.getRelativeCoords(cc, ev);
              var x = Math.clamp(xy.x, 0, width-1);
              var y = Math.clamp(xy.y, 0, height-1);
              var c = self.colorAt(self.ctx, x, y);
              self.cursor.moveTo(rect.left+x, rect.top+y);
              self.callback(c);
              ev.preventDefault();
            }
          }, false);
          window.addEventListener('mouseup', function(ev) {
            hc.down = false;
            cc.down = false;
          }, false);
          container.appendChild(this.hueCanvas);
          var w = this.ctx.createLinearGradient(0,0,width-1,height-1);
          w.addColorStop(0, 'rgba(255,255,255,1)');
          w.addColorStop(0.5000, 'rgba(255,255,255,0)');
          w.addColorStop(0.5001, 'rgba(0,0,0,0)');
          w.addColorStop(1, 'rgba(0,0,0,1)');
          this.valueGradient = w;
          this.setHue(0);
        },

        setHue : function(hue) {
          var w = this.canvas.width;
          var h = this.canvas.height;
          var last = this.hsv2rgb(this.hue, 1, 1);
          last[3] = 1;
          this.hueCtx.fillStyle = this.colorToStyle(last);
          this.hueCtx.fillRect(Math.floor(this.hue/360*w), 3, 1, this.hueCanvas.height);
          this.hueCtx.fillStyle = 'black';
          this.hueCtx.fillRect(Math.floor(hue/360*w), 3, 1, this.hueCanvas.height);
          this.hue = hue;
          var rgb = this.hsv2rgb(hue, 1, 1);
          var opposite = this.hsv2rgb(hue, 0, 0);
          var g = this.ctx.createLinearGradient(w-1, 0, 0, h-1);
          rgb[3] = opposite[3] = 1;
          g.addColorStop(1, this.colorToStyle(opposite));
          g.addColorStop(0, this.colorToStyle(rgb));
          this.ctx.fillStyle = g;
          this.ctx.fillRect(0,0,w,h);
          this.ctx.fillStyle = this.valueGradient;
          this.ctx.fillRect(0,0,w,h);
        }
      });


      Draw = Klass(Undoable, ColorUtils, {
        lineWidth : 1,
        opacity : 1,
        color : [0,0,0,1],
        background : [1,1,1,1],
        lineCap : 'round',
        pickRadius : 1,
        current : null,
        prev : null,

        initialize : function(canvas) {
          this.canvas = canvas;
          this.ctx = canvas.getContext('2d');
          this.canvas.style.cursor = 'url('+E.canvas(1,1).toDataURL()+'),crosshair';
          Undoable.initialize.call(this);
          this.current = {x:0,y:0};
          this.cursor = new RoundBrushCursor();
          this.cursor.update(this.lineWidth);
          this.cursor.moveTo(this.current.x, this.current.y);
          this.setColor(this.color);
          this.setBackground(this.background);
          this.setLineCap(this.lineCap);
          this.setLineWidth(this.lineWidth);
          this.clear();
          this.listeners = {};
          this.createListeners();
          this.addListeners();
        },

        getState : function() {
          return {
            pickRadius : this.pickRadius,
            color : this.color,
            background : this.background,
            lineWidth : this.lineWidth,
            opacity : this.opacity,
            lineCap : this.lineCap
          };
        },

        applyState : function(state) {
          this.pickRadius = state.pickRadius;
          this.setColor(state.color);
          this.setBackground(state.background);
          this.setLineCap(state.lineCap);
          this.setLineWidth(state.lineWidth);
          this.setOpacity(state.opacity);
        },

        createSnapshot : function() {
          return {
            state: this.getState(),
            imageData: this.ctx.getImageData(0,0,this.canvas.width, this.canvas.height)
          }
        },

        applySnapshot : function(snapshot) {
          this.ctx.putImageData(snapshot.imageData,0,0);
          this.applyState(snapshot.state);
        },

        applyHistoryState : function(state) {
          this[state.methodName].apply(this, state.args);
        },

        createSaveObject : function() {
          return {
            history: this.history,
            historyIndex : this.historyIndex,
            width: this.canvas.width,
            height: this.canvas.height
          };
        },

        applySaveObject : function(obj) {
          this.clear();
          this.clearHistory();
          this.canvas.width = obj.width;
          this.canvas.height = obj.height;
          for (var i=0; i<obj.history.length; i++) {
            this.applyHistoryState(obj.history[i]);
          }
          this.gotoHistoryState(obj.historyIndex);
        },

        addListeners : function() {
          for (var i in this.listeners) {
            if (this.listeners.hasOwnProperty(i)) {
              window.addEventListener(i, this.listeners[i], false);
            }
          }
        },

        removeListeners : function() {
          for (var i in this.listeners) {
            if (this.listeners.hasOwnProperty(i)) {
              window.removeEventListener(i, this.listeners[i], false);
            }
          }
        },

        createListeners : function() {
          var draw = this;
          this.listeners['mousemove'] = function(ev) {
            draw.current = Mouse.getRelativeCoords(draw.canvas, ev);
            if (draw.resizingBrush) {
              draw.keepResizingBrush();
            } else {
              draw.cursor.moveTo(draw.current.x, draw.current.y);
            }
            if (Mouse.state[Mouse.LEFT] && draw.mousedown) {
              if (draw.prev != null) {
                if (!ev.shiftKey)
                  draw.constraint = null;
                if (ev.shiftKey && !draw.constraint) {
                  var dx = draw.current.x - draw.prev.x;
                  var dy = draw.current.y - draw.prev.y;
                  if (Math.abs(dx) > Math.abs(dy))
                    draw.constraint = {y: draw.prev.y};
                  else
                    draw.constraint = {x: draw.prev.x};
                }
                if (draw.constraint) {
                  Object.extend(draw.current, draw.constraint);
                }
                draw.drawLine(draw.prev, draw.current);
              }
              draw.prev = draw.current;
              Event.stop(ev);
            }
          }
          this.listeners['mousedown'] = function(ev) {
            draw.current = Mouse.getRelativeCoords(draw.canvas, ev);
            draw.cursor.moveTo(draw.current.x, draw.current.y);
            draw.stopResizingBrush();
            if (Mouse.state[Mouse.LEFT] && ev.target == draw.canvas) {
              draw.mousedown = true;
              if (ev.shiftKey && draw.mouseup) {
                draw.constraint = null;
                draw.drawLine(draw.mouseup, draw.current, true);
                draw.prev = null;
              } else {
                draw.drawPoint(draw.current);
                draw.prev = draw.current;
              }
              ev.preventDefault();
            }
          }
          this.listeners['mouseup'] = function(ev) {
            draw.stopResizingBrush();
            if (draw.mousedown)
              ev.preventDefault();
            draw.mousedown = false;
            draw.mouseup = Mouse.getRelativeCoords(draw.canvas, ev);
            if (!Mouse.state[Mouse.LEFT]) {
              draw.prev = null;
            }
          };
          this.listeners['keydown'] = function(ev) {
            if (Key.match(ev, ['f'])) {
              draw.startResizingBrush();
            } else if (Key.match(ev, ['z'])) {
              if (ev.shiftKey)
                draw.redo();
              else
                draw.undo();
            } else if (Key.match(ev, ['r'])) {
              draw.pickColor(draw.current, draw.pickRadius);
            }
          };
          this.listeners['keyup'] = function(ev) {
            draw.stopResizingBrush();
            if (Key.match(ev, Key.DELETE)) {
              draw.clear();
            } else if (Key.match(ev, ['f'])) {
              // stopped resize above
            } else if (Key.match(ev, ['c'])) {
              //draw.setOpacity(draw.opacity - 0.25);
            } else if (Key.match(ev, ['v'])) {
              //draw.setOpacity(draw.opacity + 0.25);
            } else if (Key.match(ev, ['1','2','3','4','5','6','7','8','9'])) {
              var tgt = byClass('paletteColor')[ev.which - 49];
              draw.setColor(tgt.getAttribute('color'));
            }
          };
        },

        startResizingBrush : function() {
          if (this.resizingBrush) return;
          this.resizingBrush = true;
          this.brushResizeX = this.current.x - this.lineWidth;
        },

        keepResizingBrush : function() {
          if (!this.resizingBrush) return;
          var d = Math.max(this.current.x - this.brushResizeX, 0);
          var dx = Math.max(0.75, d);
          this.setLineWidth(dx);
        },

        stopResizingBrush : function() {
          if (!this.resizingBrush) return;
          this.resizingBrush = false;
          var d = Math.max(this.current.x - this.brushResizeX, 0);
          var dx = Math.max(0.75, d);
          this.setLineWidth(dx);
        },

        clear : function() {
          this.ctx.fillStyle = this.colorToStyle(this.background);
          this.ctx.fillRect(0,0, this.canvas.width, this.canvas.height);
          this.addHistoryState({methodName: 'clear', args: [], breakpoint: true});
        },

        drawPoint : function(xy) {
          this.ctx.beginPath();
          this.ctx.arc(xy.x, xy.y, this.lineWidth/2, 0, Math.PI*2);
          this.ctx.fillStyle = this.tweenColor(this.background, this.color, this.opacity);
          this.ctx.fill();
          this.addHistoryState({methodName: 'drawPoint', args:[xy], breakpoint: true});
        },

        drawLine : function(prev, current, breakpoint) {
          this.ctx.beginPath();
          this.ctx.moveTo(prev.x, prev.y);
          this.ctx.lineTo(current.x, current.y);
          this.ctx.stroke();
          var s = {methodName: 'drawLine', args:[prev, current]}
          if (breakpoint) {
            s.breakpoint = true;
            s.args.push(true);
          }
          this.addHistoryState(s);
        },

        setColor : function(color) {
          if (typeof color == 'string')
            this.color = this.styleToColor(color);
          else
            this.color = color;
          byId('foregroundColor').style.backgroundColor = this.colorToStyle(this.color);
          this.ctx.strokeStyle = this.tweenColor(this.background, this.color, this.opacity);
          this.addHistoryState({methodName: 'setColor', args:[this.color]});
        },

        setBackground : function(color) {
          if (typeof color == 'string')
            this.background = this.styleToColor(color);
          else
            this.background = color;
          byId('backgroundColor').style.backgroundColor = this.colorToStyle(this.background);
          this.ctx.strokeStyle = this.tweenColor(this.background, this.color, this.opacity);
          this.addHistoryState({methodName: 'setBackground', args:[this.background]});
        },

        setOpacity : function(o) {
          o = Math.clamp(o, 0, 1);
          this.opacity = o;
          this.setColor(this.color);
          this.addHistoryState({methodName: 'setOpacity', args:[this.opacity]});
        },

        setLineCap : function(lineCap) {
          this.ctx.lineCap = lineCap;
          this.lineCap = this.ctx.lineCap;
          this.addHistoryState({methodName: 'setLineCap', args:[this.lineCap]});
        },

        setLineWidth : function(w) {
          this.ctx.lineWidth = w;
          this.lineWidth = this.ctx.lineWidth;
          this.cursor.update(this.lineWidth);
          // collapse multiple setLineWidth calls into a single history event
          var last = this.history.last();
          if (last && last.methodName == 'setLineWidth')
            last.args[0] = this.lineWidth;
          else
            this.addHistoryState({methodName: 'setLineWidth', args:[this.lineWidth]});
        },

        pickColor : function(xy, radius) {
          if (xy) {
            var c = this.colorAt(this.ctx, xy.x, xy.y, radius);
            this.setColor(c);
          }
        },

        pickBackground : function(xy, radius) {
          if (xy) {
            var c = this.colorAt(this.ctx, xy.x, xy.y, radius);
            this.setBackground(c);
          }
        },

        export : function() {
          var dataURL = this.canvas.toDataURL('image/png');
          window.open(dataURL);
        },

        load : function(string) {
          var obj = new DrawHistorySerializer().deserialize(string);
          this.applySaveObject(obj);
        },

        save : function() {
          var string = new DrawHistorySerializer().serialize(this.createSaveObject());
          var b64 = btoa(string);
          window.open('data:image/x-scribble;base64,'+b64);
        }

      });

    </script>
    <script>

      window.addEventListener('resize', function() {
        if (draw.canvas.width < window.innerWidth || draw.canvas.height < window.innerHeight) {
          var id = draw.ctx.getImageData(0,0,draw.canvas.width,draw.canvas.height);
          draw.canvas.width = window.innerWidth;
          draw.canvas.height = window.innerHeight;
          draw.ctx.putImageData(id, 0,0);
          var s = draw.getState();
          var rh = draw.recordHistory;
          draw.recordHistory = false;
          draw.applyState(s);
          draw.recordHistory = rh;
        }
      }, false);

      window.addEventListener('load', function() {
        var c = E.canvas(window.innerWidth,window.innerHeight);
        c.style.position = 'absolute';
        c.style.left = c.style.top = '0px';
        document.body.appendChild(c);
        draw = new Draw(c);

        byId('replay').onclick = function(){
          draw.playbackHistory();
        };
        byId('save').onclick = function(){
          draw.save();
        };
        byId('load').onchange = function(){
          if (this.files.length > 0) {
            var reader = new FileReader();
            reader.onloadend = function(res) {
              draw.load(this.result);
            };
            reader.readAsBinaryString(this.files[0]);
          }
        };
        byId('export').onclick = function(){
          draw.export();
        };
        /*
        byId('clear').onclick = function(){
          draw.clear();
        };
        */
        byId('new').onclick = function(){
          draw.clearHistory();
          draw.clear();
        };

        var picker = byId('colorPicker');
        new ColorPicker(picker, 128, 128, function(c) {
          draw.setColor(c);
        });
        var fg = byId('foregroundColor');
        fg.setAttribute('draggable', 'true');
        fg.addEventListener('dragstart', function(ev) {
          ev.dataTransfer.effectAllowed = 'copy';
          ev.dataTransfer.dropEffect = 'copy';
          ev.dataTransfer.setData('text/plain', this.style.backgroundColor);
          ev.dataTransfer.setDragImage(ev.target, 5, 5);
        }, false);

        var ps = byClass('paletteColor');
        for (var i=0; i<ps.length; i++) {
          ps[i].style.backgroundColor = ps[i].getAttribute('color');
          ps[i].setColor = function(s) {
            this.setAttribute('color', s);
            this.style.backgroundColor = s;
          }
          ps[i].addEventListener('dragover', function(ev) {
            ev.preventDefault();
          }, false);
          ps[i].addEventListener('drop', function(ev) {
            if (ev.dataTransfer.getData('text/plain'))
              this.setColor(ev.dataTransfer.getData('text/plain'));
            ev.preventDefault();
          }, false);
          ps[i].addEventListener('click', function(ev){
            draw.setColor(this.getAttribute('color'));
            if (ev)
              Event.stop(ev);
          }, false);
        }
        var ps = byClass('brushWidth');
        for (var i=0; i<ps.length; i++) {
          ps[i].style.borderLeft = ps[i].getAttribute('value') + "px solid black";
          ps[i].onclick = function(ev){
            draw.setLineWidth(this.getAttribute('value'));
            if (ev)
              Event.stop(ev);
          };
        }

      }, false);

      toggleHelp = function() {
        var h = byId('help');
        h.style.display = h.style.display == 'block' ? 'none' : 'block';
      }
    </script>
  </head>
  <body>
    <div id="fileIO">
      <button id="new">New</button>
      <input type="file" id="load" value=""></input>
      <button id="save">Save</button>
      <button id="export">Export Image</button>
      <button id="replay">Replay</button>
      <div id="helpToggle" onclick="toggleHelp()">?</div>
      <div id="help">
        <p>Use the Keyboard, Luke!</p>
        <p>drag current color to palette</p>
        <p>1-5 choose colors from palette</p>
        <p>r picks color under cursor</p>
        <p>f + move mouse to resize brush</p>
        <p>shift draws with constraints</p>
        <p>shift-click to do straight lines</p>
        <p>z is undo</p>
        <p>shift-z is redo</p>
        <p>delete clears the canvas</p>
      </div>
    </div>
    <div id="palette">
      <div id="colorPicker"></div>

      <div id="foregroundColor"></div>
      <div id="backgroundColor"></div>

      <div class="paletteColor" color="#000000"></div>
      <div class="paletteColor" color="#ffffff"></div>
      <div class="paletteColor" color="#c02008"></div>
      <div class="paletteColor" color="#08c010"></div>
      <div class="paletteColor" color="#3040f0"></div>

      <div class="brushWidth" value="9"></div>
      <div class="brushWidth" value="5"></div>
      <div class="brushWidth" value="3"></div>
      <div class="brushWidth" value="2"></div>
      <div class="brushWidth" value="1"></div>
    </div>
  </body>
</html>